[![CI](https://github.com/cristianglezm/EvoGarden/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/cristianglezm/EvoGarden/actions/workflows/ci.yml) [![CD](https://github.com/cristianglezm/EvoGarden/actions/workflows/cd.yml/badge.svg)](https://github.com/cristianglezm/EvoGarden/actions/workflows/cd.yml)

> [!NOTE]
> This project was created as an experiment with Google's Gemini 2.5 to explore what the LLM would build by giving it the API documentation of [@cristianglezm/flower-evolver-wasm](https://github.com/cristianglezm/FlowerEvolver-WASM) a npm package.
> it made an emoji ecosystem where flowers evolve and survive, insects reproduce and pollinate the flowers, birds hunt insects not protected by the flowers.

# EvoGarden: A Predator-Prey Simulation

A dynamic garden simulation where flowers evolve under the pressure of insects and birds. Watch a Darwinian battlefield unfold as flowers, insects, and birds interact in a delicate ecosystem, with visual traits driven by the NEAT algorithm.

## ‚ú® Features

-   **High-Performance Canvas Rendering**: The entire simulation grid is rendered on a single `<canvas>` element, ensuring smooth performance even with hundreds of entities.
-   **User Goals & Scenarios (Challenges)**: Engage with a set of predefined challenges that track your progress across multiple playthroughs, from a flower surviving for a certain number of ticks to achieving ecological milestones like total insects predated.
-   **Data Visualization & Analytics**: Monitor the health and evolution of your garden over time with dynamic, real-time charts. Track population dynamics, key ecosystem events (including reproductions, predations, **eggs laid**, and **insects born**), and the average expression of genetic traits across your flower population.
-   **Dynamic Insect Lifecycle**: Insects reproduce by laying eggs of their species. These eggs have a gestation period to hatch, creating a more realistic and engaging population model.
-   **Layered Actor System**: Actors like insects and birds can occupy the same grid cell as flowers, allowing for more realistic interactions like pollination and predation.
-   **Simulation State Persistence**: Save your garden's state to your browser's local storage and load it back in a future session.
-   **Collapsible UI**: The controls and data panels are slide-out sidebars, keeping the main view clean and focused on the simulation.
-   **Real-time Event Notifications**: A non-intrusive toast system provides live feedback on key events, like a bird preying on an insect or an egg hatching.
-   **Procedural 2D Flowers**: Each flower's appearance is determined by its unique genome, procedurally generated by [@cristianglezm/flower-evolver-wasm](https://github.com/cristianglezm/FlowerEvolver-WASM) and rendered in real-time.
-   **Configurable Flower Detail**: Adjust the radius of flowers (from 4 to 64) to balance visual complexity with performance.
-   **Genome & Environment-Driven Stats**: A flower's core statistics (e.g., max health, stamina, maturation period, nutrient efficiency) are all calculated from its genome in response to the current environmental conditions (temperature, humidity), meaning traits that improve survival can be naturally selected.
-   **Dynamic Ecosystem**: An interactive simulation of flowers, pollinating insects, and predatory birds whose actions directly impact the environment.
-   **WASM-Powered Genetics**: A high-performance WebAssembly module handles complex genetic operations like mutation, reproduction, and stat calculation.
-   **Interactive Simulation**: Control world parameters like climate and population, pause/play the world, and reset with new initial conditions.
-   **Inspect Individuals**: Click on any flower to view its detailed real-time stats, including health, age, genetic traits, and its raw genome, which can be copied or downloaded as a JSON file.
-   **Interactive 3D Flower Viewer**: Generate and view a 3D model of any flower from its genome in an interactive modal viewer with camera controls. The simulation automatically pauses while viewing.
-   **Intuitive Interaction**: Click on an empty cell or outside the details panel to close it and seamlessly resume the simulation, providing a fluid user experience.

## üõ†Ô∏è Tech Stack

-   **Frontend**: React, TypeScript, Vite
-   **3D Rendering**: `@react-three/fiber`, `@react-three/drei`, `three.js`
-   **State Management**: Zustand (for toast notifications, challenges, and analytics)
-   **Data Visualization**: ECharts for React
-   **Core Logic**: Custom WebAssembly (WASM) module ([@cristianglezm/flower-evolver-wasm](https://github.com/cristianglezm/FlowerEvolver-WASM))
-   **Styling**: Tailwind CSS, PostCSS (providing a green and light-green theme).

## üî¨ Simulation Deep Dive

### Performance & Architecture
-   **Canvas Rendering**: The simulation is rendered on a single HTML `<canvas>` element for optimal performance, avoiding the overhead of managing thousands of DOM elements.
-   **Multi-Quadtree Optimization**: The simulation uses multiple Quadtree data structures each tick for high-performance spatial querying.
    -   A Quadtree for all actors is used for general lookups.
    -   A dedicated Quadtree for **flowers** allows insects to find the nearest flower efficiently.
    -   A dedicated Quadtree for **insects** allows for nearly instantaneous proximity checks for reproduction and bird targeting. This avoids slow, full-grid scans and ensures the simulation remains fast and responsive even on large, dense maps.

### Actors & Behaviours
-   **Flowers**: The foundation of the ecosystem. Their appearance and base stats (max health, stamina, maturation period, nutrient efficiency, etc.) are all dictated by their genome's response to the environment.
    -   **Lifecycle**: They lose stamina each tick at a rate defined by `FLOWER_TICK_COST_MULTIPLIER`. If stamina runs out, they begin to lose health. They heal by absorbing nutrients from the grid cell below them, with an effectiveness determined by their genetic `nutrientEfficiency` trait. If their health reaches zero, they wither and are removed.
    -   **Reproduction**: Flowers must reach their unique, genetically-determined `maturationPeriod` before they can reproduce. Pollination can occur in three ways:
        1.  **Proximity Pollination**: A small chance to reproduce with an adjacent mature flower.
        2.  **Insect Pollination**: Insects carry the "pollen" (genome) from one flower to another, triggering reproduction.
        3.  **Wind Pollination**: A mature flower has a chance to release its pollen, which travels in the prevailing wind direction. If it lands on another mature flower, they reproduce. This allows for long-distance sexual reproduction.
    -   **Spawning Logic**: To prevent the ecosystem from becoming gridlocked by insect eggs, new flowers are intelligent enough to spawn on cells that are either empty or currently occupied only by eggs or nutrients.
-   **Insects** (`ü¶ã`, `üêõ`, `üêå`, `üêû`, `üêù`):
    -   **AI & Movement**: Insects move with purpose. They use a Quadtree to find the nearest flower within their vision range and move towards it. If no flowers are nearby, they revert to random wandering.
    -   **Interaction**: Upon moving onto a cell with a flower, they inflict a tiny amount of damage and pick up its pollen (genome and source flower ID). When they visit the next mature flower, they deposit the pollen, triggering a reproduction event. To encourage genetic diversity, an insect cannot pollinate a flower with its own pollen.
    -   **Reproduction**: If two insects of the same species land on the same cell, they have a chance to lay an egg in a nearby empty cell. This check is optimized using a dedicated insect Quadtree.
    -   **Lifecycle**: To prevent population explosions, insects have a limited lifespan. After a set number of ticks, they die of old age and decompose, leaving behind a nutrient on their cell to continue the ecosystem's cycle.
-   **Eggs** (`ü•ö`): The offspring of insects. They remain stationary and have a fixed `hatchTimer`. Each tick, the timer decrements. When it reaches zero, the egg is removed and a new insect of the parent's species spawns in its place.
-   **Birds** (`üê¶`): The predators of the garden.
    -   **AI & Movement**: They move randomly until they detect prey within their vision range (using a Quadtree for efficiency).
    -   **Predation Strategy**: Birds have a target priority. They prefer to hunt moving insects but will resort to eating stationary eggs if no unprotected insects are nearby.
    -   **Prey Protection**: Birds cannot see or prey on an insect while it is resting on the same cell as a flower. This makes flowers a crucial safe haven for insects.
    -   **Nutrient Cycle**: After killing an insect, the bird leaves behind a nutrient-rich dropping (`üí©`) in that cell. Eating an egg does not produce a nutrient.

### Nutrients & The Ecosystem Loop
Nutrients (`üí©`) are the simulation's core resource.
-   **Creation**: They appear where a bird was (random droppings), where an insect was predated, or where an insect died of old age.
-   **Consumption**: Nutrients provide an area-of-effect heal. A nutrient will instantly heal all flowers in a 3x3 area around it (the flower on its own cell and all 8 neighbors) before being consumed and removed from the simulation.
-   **Decay**: Unused nutrients have a limited lifespan and will disappear after a set number of ticks.
This creates a dynamic resource cycle: predators consume prey -> deaths create nutrients -> nutrients heal flowers -> healthy flowers support more prey -> more prey supports more predators. This feedback loop drives natural selection, favoring flowers with genomes that are best adapted to the current resource and predator levels.

## üß¨ The Genetics Engine: `@cristianglezm/flower-evolver-wasm`

The visual variety and evolutionary mechanics are powered by a custom WebAssembly module. This service is responsible for creating and manipulating the genetic code of the flowers and rendering them as SVGs or 3D models.

**Important Note**: This service only handles the *genetic and visual* aspects of a flower. It does not track in-simulation state like `health`, `stamina`, or `age`. That state is managed entirely within the `SimulationEngine`.

### Core Functions:
-   `async makeFlower(): Flower`: Creates a new flower with a completely random genome.
-   `async reproduce(father: string, mother: string): Flower`: Combines the genomes of two parent flowers to create a child.
-   `async mutate(original: string, ...rates): Flower`: Applies random mutations to an existing genome.
-   `async getFlowerStats(genome: string, ...envFactors): FlowerGenomeStats`: **Core mechanic.** Takes a genome and environmental conditions (humidity, temperature) and returns a JSON object containing the flower's base statistics. This includes `health` (max), `stamina` (max), optimal `min/maxTemperature`, `maturationPeriod`, `sex`, `toxicityRate`, and an `effects` object with raw stats like `vitality`.
-   `setParams(params: FEParams)`: Configures the rendering parameters for the flowers.
-   `async draw3DFlower(genome: string): string`: Takes a flower's genome and returns a string containing a GLTF file for 3D rendering.

## üìÅ Project Structure
-   `index.html`: The single-page entry point. It contains the `<div id="root">` where the React app is mounted.
-   `package.json`: Defines project metadata, scripts (`dev`, `build`), and dependencies.
    -   **`dependencies`**: Includes `react`, `zustand`, `@cristianglezm/flower-evolver-wasm`, and the `@react-three/*` libraries.
    -   **`devDependencies`**: Includes `vite`, `typescript`, `tailwindcss`, `postcss`, `autoprefixer` for the development environment and build process.
-   `vite.config.ts`, `tailwind.config.js`, `postcss.config.js`: Configuration files for the Vite build tool and the Tailwind CSS styling pipeline.
-   `src/`: Contains all the application source code.
    -   `src/index.tsx`: The main entry point for the React application.
    -   `src/App.tsx`: The root React component. Manages global state and layout.
    -   `src/hooks/useSimulation.ts`: **Simulation Manager.** A custom hook that acts as a bridge to the simulation's Web Worker, managing its lifecycle and communication.
    -   `src/simulation.worker.ts`: **Simulation Host.** This Web Worker runs on a separate thread and acts as a message broker between the main UI thread and the simulation logic. It's primary role is to host the `SimulationEngine` to prevent the UI from freezing during heavy calculations.
    -   `src/lib/simulationEngine.ts`: **The heart of the simulation.** This class contains the main simulation loop (`calculateNextTick`), all state management (the grid, actors), and orchestrates actor logic. It is instantiated and run exclusively within the web worker.
    -   `src/lib/behaviors/`: Contains individual behavior modules for each actor type (`birdBehavior`, `insectBehavior`, etc.). These modules are called by the `SimulationEngine` to process each actor's logic for a given tick, promoting a clean separation of concerns.
    -   `src/lib/Quadtree.ts`: A generic Quadtree data structure for efficient 2D spatial queries.
    -   `src/components/SimulationView.tsx`: Renders the simulation grid onto the `<canvas>`.
    -   `src/components/Controls.tsx`: UI for changing simulation parameters.
    -   `src/components/FlowerDetailsPanel.tsx`: UI that displays the stats of the selected flower. It handles pausing the simulation when its "View in 3D" button is clicked.
    -   `src/components/Flower3DViewer.tsx`: A React-Three-Fiber component that renders the 3D flower model.
    -   `src/components/Modal.tsx`: A generic modal component.
    -   `src/components/DataPanel.tsx`: The main UI for the slide-out panel containing challenges and analytics, with a tabbed interface.
    -   `src/components/ChallengesPanel.tsx`: Renders the list of challenges and their progress from the `challengeStore`.
    -   `src/components/ChartsPanel.tsx`: Renders all the data visualization charts using data from the `analyticsStore`.
    -   `src/components/Chart.tsx`: A reusable wrapper component for the `echarts-for-react` library.
    -   `src/components/Toast.tsx`: Renders a single toast notification with a message and icon.
    -   `src/components/ToastContainer.tsx`: Manages the on-screen layout and rendering of all active toasts.
    -   `src/services/flowerService.ts`: A TypeScript singleton wrapper for the WASM module.
    -   `src/stores/toastStore.ts`: A global Zustand store for managing toast notifications.
    -   `src/stores/challengeStore.ts`: A Zustand store with `persist` middleware for tracking challenge progress across sessions.
    -   `src/stores/analyticsStore.ts`: A Zustand store with `persist` middleware for storing historical simulation data for the charts.
    -   `src/utils.ts`: A module for shared utility functions.
    -   `src/constants.ts`: Global constants for the simulation (tick rate, damage values, etc.).
    -   `src/types.ts`: Shared TypeScript types for the simulation.

## üöÄ Getting Started

Follow these instructions to get a copy of the project up and running on your local machine for development.

### Prerequisites

You need to have [Node.js](https://nodejs.org/) (version 18 or higher) and npm installed on your computer.

### Installation & Setup

1.  Clone the repository and install the required dependencies using npm:
    ```bash
    npm install
    ```

### Running Locally

2.  To start the local development server, run the following command:
    ```bash
    npm run dev
    ```
    This will start a server, and you can view the application by navigating to the URL provided in your terminal (usually `http://localhost:5173`).

## üß™ Testing

This project uses [Vitest](https://vitest.dev/) for unit and component testing and [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/) for rendering components in a test environment.

To run all tests once in the terminal, execute:
```bash
npm test
```

To run tests in interactive watch mode, which is useful during development:
```bash
npm run test:watch
```

For a more visual testing experience with a dedicated UI, run:
```bash
npm run test:ui
```

Test files are located within the `src` directory, with a global setup file at `src/test/setup.ts`.

## üß™ End-to-End Testing

This project uses [Playwright](https://playwright.dev/) for End-to-End (E2E) testing, which runs tests against a real browser to simulate user interactions.

To run all E2E tests, first make sure the development server is not running, and then execute:
```bash
npm run test:e2e
```
Playwright will automatically start the Vite server, run the tests, and then shut it down.

## üì¶ Building for Production

To create a production-ready build of the application, run:
```bash
npm run build
```
This command will type-check the code and then bundle it into a `dist` directory, which can be deployed to any static hosting service.

## üêõ Debugging with React DevTools

[React DevTools](https://github.com/facebook/react/tree/main/packages/react-devtools) is automatically configured to run alongside the development server for inspecting the React component hierarchy, state, and props.

Simply start the development server:
```bash
npm run dev
```
The React DevTools standalone application will launch automatically, and your app will connect to it. This allows you to debug your components without any extra steps.

## üö¢ Deployment

This project includes a GitHub Actions workflow for continuous deployment to GitHub Pages. Any push to the `master` branch will automatically trigger a build and deployment to the `gh-pages` branch.

Once the first deployment has run, you may need to configure your repository to serve from the `gh-pages` branch. You can do this under `Settings > Pages`.

## üìÑ License

This project is licensed under the Apache License 2.0. See the [LICENSE.md](LICENSE.md) file for details.
